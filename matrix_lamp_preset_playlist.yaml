# Пакет для добавления пресетов, плейлиста  режимов старта пресетов и плейлиста(по времени, солнцу и день\ночь)
# Подключите в основном YAML через: packages: { file: packages/matrix_lamp/matrix_lamp_preset.yaml }
esphome:
  on_boot:
    priority: -100
    then:
      - delay: 500ms
# Установить актуальный пресет
      - select.set_index:
          id: preset_selector
          index: !lambda 'return id(preset_selected);'
      - delay: 500ms
# Обновить текстовый сенсор пресетов
      - lambda: |-
          id(preset_info).update();
      - delay: 500ms
# Обновить текстовый сенсор режимов старта
      - lambda: |-
          id(preset_start_settings).update();
time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Moscow
    servers:
      - 0.ru.pool.ntp.org
      - ntp0.ntp-servers.net
      - 2.pool.ntp.org
  - platform: homeassistant
    id: homeassistant_time
sun:
  latitude: 43.00
  longitude: 33.00
  id: sun_sun
sensor:
  - platform: sun
    name: Sun Elevation
    type: elevation
  - platform: sun
    name: Sun Azimuth
    type: azimuth
globals:
  - id: preset_selected
    type: int
    restore_value: yes
    initial_value: '0'
  - id: last_preset
    type: int
    restore_value: no
    initial_value: '0'

  # Пресет 0
  - id: preset0_effect_name
    type: std::string
    restore_value: yes
    initial_value: '""'
    max_restore_data_length: 24
  - id: preset0_intensity
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset0_speed
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset0_scale
    type: int
    restore_value: yes
    initial_value: '50'
  - id: preset0_effect_mode
    type: int
    restore_value: yes
    initial_value: '0'
  - id: preset0_brightness
    type: int
    initial_value: '1'
    restore_value: yes
  - id: preset0_start_mode
    type: std::string
    restore_value: yes
    initial_value: '""'
    max_restore_data_length: 15
  - id: preset0_start_time
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
# initial_value: '00:00:00'
  - id: preset0_sunrise_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset0_sunset_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset0_check_playlist
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: preset0_duration_playlist
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
  - id: preset0_duration_ms
    type: int
    restore_value: yes
    initial_value: '60000'  # 60 секунд по умолчанию
    max_restore_data_length: 8

# Пресет 1
  - id: preset1_effect_name
    type: std::string
    restore_value: yes
    initial_value: '""'
    max_restore_data_length: 24
  - id: preset1_intensity
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset1_speed
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset1_scale
    type: int
    restore_value: yes
    initial_value: '50'
  - id: preset1_effect_mode
    type: int
    restore_value: yes
    initial_value: '1'
  - id: preset1_brightness
    type: int
    initial_value: '1'
    restore_value: yes
  - id: preset1_start_mode
    type: std::string
    restore_value: yes
    initial_value: '""'
    max_restore_data_length: 15
  - id: preset1_start_time
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
# initial_value: '00:00:00'
  - id: preset1_sunrise_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset1_sunset_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset1_check_playlist
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: preset1_duration_playlist
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
  - id: preset1_duration_ms
    type: int
    restore_value: yes
    initial_value: '60000'  # 60 секунд по умолчанию
    max_restore_data_length: 8

# Пресет 2
  - id: preset2_effect_name
    type: std::string
    initial_value: '""'
    restore_value: yes
    max_restore_data_length: 24
  - id: preset2_intensity
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset2_speed
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset2_scale
    type: int
    restore_value: yes
    initial_value: '50'
  - id: preset2_effect_mode
    type: int
    restore_value: yes
    initial_value: '2'
  - id: preset2_brightness
    type: int
    initial_value: '1'
    restore_value: yes
  - id: preset2_start_mode
    type: std::string
    restore_value: yes
    initial_value: '""'
    max_restore_data_length: 15
  - id: preset2_start_time
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
# initial_value: '00:00:00'
  - id: preset2_sunrise_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset2_sunset_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset2_check_playlist
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: preset2_duration_playlist
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
  - id: preset2_duration_ms
    type: int
    restore_value: yes
    initial_value: '60000'  # 60 секунд по умолчанию
    max_restore_data_length: 8

# Пресет 3
  - id: preset3_effect_name
    type: std::string
    initial_value: '""'
    restore_value: yes
    max_restore_data_length: 24
  - id: preset3_intensity
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset3_speed
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset3_scale
    type: int
    restore_value: yes
    initial_value: '50'
  - id: preset3_effect_mode
    type: int
    restore_value: yes
    initial_value: '2'
  - id: preset3_brightness
    type: int
    initial_value: '1'
    restore_value: yes
  - id: preset3_start_mode
    type: std::string
    restore_value: yes
    initial_value: '""'
    max_restore_data_length: 15
  - id: preset3_start_time
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
# initial_value: '00:00:00'
  - id: preset3_sunrise_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset3_sunset_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset3_check_playlist
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: preset3_duration_playlist
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
  - id: preset3_duration_ms
    type: int
    restore_value: yes
    initial_value: '60000'  # 60 секунд по умолчанию
    max_restore_data_length: 8

# Пресет 4
  - id: preset4_effect_name
    type: std::string
    initial_value: '""'
    restore_value: yes
    max_restore_data_length: 24
  - id: preset4_intensity
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset4_speed
    type: int
    restore_value: yes
    initial_value: '128'
  - id: preset4_scale
    type: int
    restore_value: yes
    initial_value: '50'
  - id: preset4_effect_mode
    type: int
    restore_value: yes
    initial_value: '2'
  - id: preset4_brightness
    type: int
    initial_value: '1'
    restore_value: yes
  - id: preset4_start_mode
    type: std::string
    restore_value: yes
    initial_value: '""'
    max_restore_data_length: 15
  - id: preset4_start_time
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
# initial_value: '00:00:00'
  - id: preset4_sunrise_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset4_sunset_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: preset4_check_playlist
    type: bool
    restore_value: yes
    initial_value: 'false'
  - id: preset4_duration_playlist
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
  - id: preset4_duration_ms
    type: int
    restore_value: yes
    initial_value: '60000'  # 60 секунд по умолчанию
    max_restore_data_length: 8

# Playlist
  - id: playlist_start_mode
    type: std::string
    restore_value: yes
    initial_value: '""'
    max_restore_data_length: 15
  - id: playlist_start_time
    type: std::string
    restore_value: yes
    max_restore_data_length: 12
# initial_value: '00:00:00'
  - id: playlist_sunrise_correction
    type: float
    restore_value: yes
    initial_value: '0.0'
  - id: playlist_sunset_correction
    type: float
    restore_value: yes
    initial_value: '0.0'

button:
  - platform: template
    name: "Save Preset"
    on_press:
      then:
        - lambda: |-
            float brightness = id(neopixel_led).current_values.get_brightness();
            int bright_int = (int)(brightness * 255);

            int index = id(preset_selected);

            switch(index) {
              case 0:
                id(preset0_effect_name) = id(neopixel_led)->get_effect_name();
                id(preset0_intensity) = (int)id(matrix_intensity).state;
                id(preset0_speed) = (int)id(matrix_speed).state;
                id(preset0_scale) = (int)id(matrix_scale).state;
                id(preset0_brightness) = bright_int;
                ESP_LOGI("main", "Preset 0 saved");
                break;

              case 1:
                id(preset1_effect_name) = id(neopixel_led)->get_effect_name();
                id(preset1_intensity) = (int)id(matrix_intensity).state;
                id(preset1_speed) = (int)id(matrix_speed).state;
                id(preset1_scale) = (int)id(matrix_scale).state;
                id(preset1_brightness) = bright_int;
                ESP_LOGI("main", "Preset 1 saved");
                break;

              case 2:
                id(preset2_effect_name) = id(neopixel_led)->get_effect_name();
                id(preset2_intensity) = (int)id(matrix_intensity).state;
                id(preset2_speed) = (int)id(matrix_speed).state;
                id(preset2_scale) = (int)id(matrix_scale).state;
                id(preset2_brightness) = bright_int;
                ESP_LOGI("main", "Preset 2 saved");
                break;

              case 3:
                id(preset3_effect_name) = id(neopixel_led)->get_effect_name();
                id(preset3_intensity) = (int)id(matrix_intensity).state;
                id(preset3_speed) = (int)id(matrix_speed).state;
                id(preset3_scale) = (int)id(matrix_scale).state;
                id(preset3_brightness) = bright_int;
                ESP_LOGI("main", "Preset 3 saved");
                break;

              case 4:
                id(preset4_effect_name) = id(neopixel_led)->get_effect_name();
                id(preset4_intensity) = (int)id(matrix_intensity).state;
                id(preset4_speed) = (int)id(matrix_speed).state;
                id(preset4_scale) = (int)id(matrix_scale).state;
                id(preset4_brightness) = bright_int;
                ESP_LOGI("main", "Preset 4 saved");
                break;

              default:
                ESP_LOGW("main", "Unknown preset index %d", index);
                break;
            }

        # добавляем сохранение коррекции угла по режиму sunrise/sunset
        - lambda: |-
            int preset = id(preset_selected);
            std::string start_mode = id(mode_selector).state;
            float correction_value = (float)id(sun_elevation_correction).state;

            if (start_mode == "sunrise") {
              switch(preset) {
                case 0: id(preset0_sunrise_correction) = correction_value; break;
                case 1: id(preset1_sunrise_correction) = correction_value; break;
                case 2: id(preset2_sunrise_correction) = correction_value; break;
                case 3: id(preset3_sunrise_correction) = correction_value; break;
                case 4: id(preset4_sunrise_correction) = correction_value; break;
                case 5: id(playlist_sunrise_correction) = correction_value; break;
              }
            } else if (start_mode == "sunset") {
              switch(preset) {
                case 0: id(preset0_sunset_correction) = correction_value; break;
                case 1: id(preset1_sunset_correction) = correction_value; break;
                case 2: id(preset2_sunset_correction) = correction_value; break;
                case 3: id(preset3_sunset_correction) = correction_value; break;
                case 4: id(preset4_sunset_correction) = correction_value; break;
                case 5: id(playlist_sunset_correction) = correction_value; break;
              }
            }
# Запоминаем время из datetime
        - lambda: |-
            // Получаем выбранный пресет (целочисленное значение)
            int preset = id(preset_selected);

            // Форматируем выбранное время в строку "HH:MM"
            char buf[6];
            snprintf(buf, sizeof(buf), "%02d:%02d", id(datetime_picker).hour, id(datetime_picker).minute);
            std::string time_str(buf);

            // Получаем текущий режим старта для выбранного пресета (например, для Playlist)
            std::string start_mode = id(mode_selector).state;

            if (preset == 5) {  // Playlist-всегда сохраняем время старта (независимо от режима)
              id(playlist_start_time) = time_str;
              ESP_LOGI("save", "Playlist start time saved: %s", time_str.c_str());
            } else {  // Если mode_selector == "in playlist" (для presets 0-4) Сохранять время как длительность в формате MM:SS в presetX_duration_playlist (string) и парсить в миллисекунды в presetX_duration_ms
              if (start_mode == "in playlist") {
                // Сохраняем как длительность MM:SS и парсим в ms
                if (preset == 0) {
                  id(preset0_duration_playlist) = time_str;
                  int mm = id(datetime_picker).hour;
                  int ss = id(datetime_picker).minute;
                  if (mm < 0 || mm > 59 || ss < 0 || ss > 59) {
                    ESP_LOGW("save", "Invalid MM:SS values for preset0: %d:%d", mm, ss);
                    return;
                  }
                  int total_ms = (mm * 60 + ss) * 1000;
                  id(preset0_duration_ms) = total_ms;
                  ESP_LOGI("save", "Preset0 playlist duration saved: %s -> %d ms", time_str.c_str(), total_ms);
                } else if (preset == 1) {
                  id(preset1_duration_playlist) = time_str;
                  int mm = id(datetime_picker).hour;
                  int ss = id(datetime_picker).minute;
                  if (mm < 0 || mm > 59 || ss < 0 || ss > 59) return;
                  int total_ms = (mm * 60 + ss) * 1000;
                  id(preset1_duration_ms) = total_ms;
                  ESP_LOGI("save", "Preset1 playlist duration saved: %s -> %d ms", time_str.c_str(), total_ms);
                } else if (preset == 2) {
                  id(preset2_duration_playlist) = time_str;
                  int mm = id(datetime_picker).hour;
                  int ss = id(datetime_picker).minute;
                  if (mm < 0 || mm > 59 || ss < 0 || ss > 59) return;
                  int total_ms = (mm * 60 + ss) * 1000;
                  id(preset2_duration_ms) = total_ms;
                  ESP_LOGI("save", "Preset2 playlist duration saved: %s -> %d ms", time_str.c_str(), total_ms);
                } else if (preset == 3) {
                  id(preset3_duration_playlist) = time_str;
                  int mm = id(datetime_picker).hour;
                  int ss = id(datetime_picker).minute;
                  if (mm < 0 || mm > 59 || ss < 0 || ss > 59) return;
                  int total_ms = (mm * 60 + ss) * 1000;
                  id(preset3_duration_ms) = total_ms;
                  ESP_LOGI("save", "Preset3 playlist duration saved: %s -> %d ms", time_str.c_str(), total_ms);
                } else if (preset == 4) {
                  id(preset4_duration_playlist) = time_str;
                  int mm = id(datetime_picker).hour;
                  int ss = id(datetime_picker).minute;
                  if (mm < 0 || mm > 59 || ss < 0 || ss > 59) return;
                  int total_ms = (mm * 60 + ss) * 1000;
                  id(preset4_duration_ms) = total_ms;
                  ESP_LOGI("save", "Preset4 playlist duration saved: %s -> %d ms", time_str.c_str(), total_ms);
                }
              } else {
                // Сохраняем как время старта HH:MM (как прежде)
                if (preset == 0) id(preset0_start_time) = time_str;
                else if (preset == 1) id(preset1_start_time) = time_str;
                else if (preset == 2) id(preset2_start_time) = time_str;
                else if (preset == 3) id(preset3_start_time) = time_str;
                else if (preset == 4) id(preset4_start_time) = time_str;
                ESP_LOGI("save", "Preset%d start time saved: %s", preset, time_str.c_str());
              }
            }

            // обновления текстовых датчиков
            id(preset_info).update();
            id(preset_start_settings).update();

select:
  - platform: template
    name: "Preset Selector"
    id: preset_selector
    optimistic: true
    initial_option: "0"
    options:
      - "0"
      - "1"
      - "2"
      - "3"
      - "4"
      - "Playlist"
      - "None"
    on_value:
      - lambda: |-
          // Переводим строку в число для сохранения
          int val = -1;
          if (id(preset_selector).state == "0") val = 0;
          else if (id(preset_selector).state == "1") val = 1;
          else if (id(preset_selector).state == "2") val = 2;
          else if (id(preset_selector).state == "3") val = 3;
          else if (id(preset_selector).state == "4") val = 4;
          else if (id(preset_selector).state == "Playlist") val = 5;
          else val = 255;  // None или другое

          if (val >= 0) {
            id(preset_selected) = val;
            ESP_LOGD("main", "preset_selected updated to %d", val);
          } else {
            ESP_LOGD("main", "preset_selected set to 255 (none)");
          }

      - lambda: |-
          int preset = id(preset_selected);
          std::string mode = id(mode_selector).state;
          float correction = 0.0f;

          if (preset >= 0 && preset <= 5) {
            if (mode == "sunrise") {
              switch(preset) {
                case 0: correction = id(preset0_sunrise_correction); break;
                case 1: correction = id(preset1_sunrise_correction); break;
                case 2: correction = id(preset2_sunrise_correction); break;
                case 3: correction = id(preset3_sunrise_correction); break;
                case 4: correction = id(preset4_sunrise_correction); break;
                case 5: correction = id(playlist_sunrise_correction); break;

              }
            } else if (mode == "sunset") {
              switch(preset) {
                case 0: correction = id(preset0_sunset_correction); break;
                case 1: correction = id(preset1_sunset_correction); break;
                case 2: correction = id(preset2_sunset_correction); break;
                case 3: correction = id(preset3_sunset_correction); break;
                case 4: correction = id(preset4_sunset_correction); break;
                case 5: correction = id(playlist_sunset_correction); break;

              }
            }
          } else if (preset == 5) {  // Playlist
            if (mode == "sunrise") correction = id(playlist_sunrise_correction);
            else if (mode == "sunset") correction = id(playlist_sunset_correction);
          }

          // Устанавливаем значение коррекции в number
          id(sun_elevation_correction).publish_state(correction);

      - if:
# Загрузка настроек для плейлиста
          condition:
            - lambda: 'return id(preset_selector).state == "Playlist";'
          then:
            - script.execute: play_preset_playlist
            - lambda: |-
                // Обновляем mode_selector согласно пресету Playlist из глобалки
                id(mode_selector).publish_state(id(playlist_start_mode));
            - lambda: |-
                // Обновляем время в datetime согласно пресету старта Playlist из глобалки
                auto call = id(datetime_picker).make_call();
                call.set_time(id(playlist_start_time).c_str());
                call.perform();
            - lambda: |-
                std::string mode = id(mode_selector).state;
                float correction = 0.0f;
                if (mode == "sunrise") correction = id(playlist_sunrise_correction);
                else if (mode == "sunset") correction = id(playlist_sunset_correction);
                id(sun_elevation_correction).publish_state(correction);
            - lambda: 'id(preset_info).update();'
          else:
            - script.stop: play_preset_playlist
      - if:
          condition:
            - lambda: 'return id(preset_selector).state == "0";'
          then:
            - script.stop: play_preset_playlist
            - lambda: |-
                float brightness = (float)id(preset0_brightness) / 255.0f;
                // Запускаем эффект с нужными параметрами
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset0_effect_name)).perform();
            - lambda: |-
                // Обновляем mode_selector согласно пресету 0 из глобалки
                id(mode_selector).publish_state(id(preset0_start_mode));
            - if:
                condition:
                  - lambda: 'return id(mode_selector).state == "in playlist";'
                then:
                  - lambda: |-
                      // Обновляем время в datetime согласно длительности пресета в  Playlist из глобалки
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset0_duration_playlist).c_str());
                      call.perform();
                else:
                  - lambda: |-
                      // Обновляем время в datetime согласно времени старта пресету
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset0_start_time).c_str());
                      call.perform();
            - lambda: |-
                std::string mode = id(mode_selector).state;
                float correction = 0.0f;
                if (mode == "sunrise") correction = id(preset0_sunrise_correction);
                else if (mode == "sunset") correction = id(preset0_sunset_correction);
                id(sun_elevation_correction).publish_state(correction);
            - delay: 100ms
            - number.set:
                id: matrix_intensity
                value: !lambda 'return id(preset0_intensity);'
            - number.set:
                id: matrix_speed
                value: !lambda 'return id(preset0_speed);'
            - number.set:
                id: matrix_scale
                value: !lambda 'return id(preset0_scale);'
            - lambda: |-
                id(preset_info).update();
      - if:
          condition:
            - lambda: 'return id(preset_selector).state == "1";'
          then:
            - script.stop: play_preset_playlist
            - lambda: |-
                float brightness = (float)id(preset1_brightness) / 255.0f;
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset1_effect_name)).perform();
            - lambda: |-
                id(mode_selector).publish_state(id(preset1_start_mode));
            - if:
                condition:
                  - lambda: 'return id(mode_selector).state == "in playlist";'
                then:
                  - lambda: |-
                      // Обновляем время в datetime согласно длительности пресета в  Playlist из глобалки
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset1_duration_playlist).c_str());
                      call.perform();
                else:
                  - lambda: |-
                      // Обновляем время в datetime согласно времени старта пресету
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset1_start_time).c_str());
                      call.perform();
            - lambda: |-
                std::string mode = id(mode_selector).state;
                float correction = 0.0f;
                if (mode == "sunrise") correction = id(preset1_sunrise_correction);
                else if (mode == "sunset") correction = id(preset1_sunset_correction);
                id(sun_elevation_correction).publish_state(correction);
            - delay: 100ms
            - number.set:
                id: matrix_intensity
                value: !lambda 'return id(preset1_intensity);'
            - number.set:
                id: matrix_speed
                value: !lambda 'return id(preset1_speed);'
            - number.set:
                id: matrix_scale
                value: !lambda 'return id(preset1_scale);'
            - lambda: |-
                id(preset_info).update();
      - if:
          condition:
            - lambda: 'return id(preset_selector).state == "2";'
          then:
            - script.stop: play_preset_playlist
            - lambda: |-
                float brightness = (float)id(preset2_brightness) / 255.0f;
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset2_effect_name)).perform();
            - lambda: |-
                id(mode_selector).publish_state(id(preset2_start_mode));
            - if:
                condition:
                  - lambda: 'return id(mode_selector).state == "in playlist";'
                then:
                  - lambda: |-
                      // Обновляем время в datetime согласно длительности пресета в  Playlist из глобалки
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset2_duration_playlist).c_str());
                      call.perform();
                else:
                  - lambda: |-
                      // Обновляем время в datetime согласно времени старта пресету
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset2_start_time).c_str());
                      call.perform();
            - lambda: |-
                std::string mode = id(mode_selector).state;
                float correction = 0.0f;
                if (mode == "sunrise") correction = id(preset2_sunrise_correction);
                else if (mode == "sunset") correction = id(preset2_sunset_correction);
                id(sun_elevation_correction).publish_state(correction);
            - delay: 100ms
            - number.set:
                id: matrix_intensity
                value: !lambda 'return id(preset2_intensity);'
            - number.set:
                id: matrix_speed
                value: !lambda 'return id(preset2_speed);'
            - number.set:
                id: matrix_scale
                value: !lambda 'return id(preset2_scale);'
            - lambda: |-
                id(preset_info).update();
      - if:
          condition:
            - lambda: 'return id(preset_selector).state == "3";'
          then:
            - script.stop: play_preset_playlist
            - lambda: |-
                float brightness = (float)id(preset3_brightness) / 255.0f;
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset3_effect_name)).perform();
            - lambda: |-
                id(mode_selector).publish_state(id(preset3_start_mode));
            - if:
                condition:
                  - lambda: 'return id(mode_selector).state == "in playlist";'
                then:
                  - lambda: |-
                      // Обновляем время в datetime согласно длительности пресета в  Playlist из глобалки
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset3_duration_playlist).c_str());
                      call.perform();
                else:
                  - lambda: |-
                      // Обновляем время в datetime согласно времени старта пресету
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset3_start_time).c_str());
                      call.perform();
            - lambda: |-
                std::string mode = id(mode_selector).state;
                float correction = 0.0f;
                if (mode == "sunrise") correction = id(preset3_sunrise_correction);
                else if (mode == "sunset") correction = id(preset3_sunset_correction);
                id(sun_elevation_correction).publish_state(correction);
            - delay: 100ms
            - number.set:
                id: matrix_intensity
                value: !lambda 'return id(preset3_intensity);'
            - number.set:
                id: matrix_speed
                value: !lambda 'return id(preset3_speed);'
            - number.set:
                id: matrix_scale
                value: !lambda 'return id(preset3_scale);'
            - lambda: |-
                id(preset_info).update();
      - if:
          condition:
            - lambda: 'return id(preset_selector).state == "4";'
          then:
            - script.stop: play_preset_playlist
            - lambda: |-
                float brightness = (float)id(preset4_brightness) / 255.0f;
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset4_effect_name)).perform();
            - lambda: |-
                id(mode_selector).publish_state(id(preset4_start_mode));
            - if:
                condition:
                  - lambda: 'return id(mode_selector).state == "in playlist";'
                then:
                  - lambda: |-
                      // Обновляем время в datetime согласно длительности пресета в  Playlist из глобалки
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset4_duration_playlist).c_str());
                      call.perform();
                else:
                  - lambda: |-
                      // Обновляем время в datetime согласно времени старта пресету
                      auto call = id(datetime_picker).make_call();
                      call.set_time(id(preset4_start_time).c_str());
                      call.perform();
            - lambda: |-
                std::string mode = id(mode_selector).state;
                float correction = 0.0f;
                if (mode == "sunrise") correction = id(preset4_sunrise_correction);
                else if (mode == "sunset") correction = id(preset4_sunset_correction);
                id(sun_elevation_correction).publish_state(correction);
            - delay: 100ms
            - number.set:
                id: matrix_intensity
                value: !lambda 'return id(preset4_intensity);'
            - number.set:
                id: matrix_speed
                value: !lambda 'return id(preset4_speed);'
            - number.set:
                id: matrix_scale
                value: !lambda 'return id(preset4_scale);'
            - lambda: |-
                id(preset_info).update();
      - if:
          condition:
            - lambda: 'return id(preset_selector).state == "None";'
          then:
            - script.stop: play_preset_playlist
            - light.turn_off:
                id: neopixel_led
            - number.set:
                id: matrix_intensity
                value: 100
            - lambda: |-
                id(preset_info).update();

  # Select для выбора режима старта пресета (например, "None", "start on time", "start on sun", "day", "night", "in Playlist")
  - platform: template
    name: "Preset Mode"          # Имя для UI
    id: mode_selector           # ID для обращения из кода
    options:
      - "None"                 # Режим, при котором старт пресета не происходит автоматически
      - "start on time"        # Запуск пресета по заданному времени
      - "sunrise"              # Запуск пресета по восходу
      - "sunset"               # Запуск пресета по закату
      - "day"                  # Запуск пресета при дневном освещении (elevation солнца выше порога)
      - "night"                # Запуск пресета при ночном освещении (elevation солнца ниже порога)
      - "in playlist"          # Добавление пресета в плейлист и установка длительности
      - "out playlist"          # Удаление пресета из плейлиста
    optimistic: true            # Значение select считается установленным сразу, без подтверждения от устройства
    initial_option: "None"      # Значение по умолчанию
    on_value:
      - lambda: |-
          int preset = id(preset_selected);
          std::string mode = id(mode_selector).state;

          // Сохраняем выбранный режим в соответствующую глобальную переменную
          if (preset == 0) id(preset0_start_mode) = mode;
          else if (preset == 1) id(preset1_start_mode) = mode;
          else if (preset == 2) id(preset2_start_mode) = mode;
          else if (preset == 3) id(preset3_start_mode) = mode;
          else if (preset == 4) id(preset4_start_mode) = mode;
          else if (preset == 5) id(playlist_start_mode) = mode;

          // Обновляем булевую переменную только для "in playlist" и "out playlist"
          if (mode == "in playlist") {
            if (preset == 0) id(preset0_check_playlist) = true;
            else if (preset == 1) id(preset1_check_playlist) = true;
            else if (preset == 2) id(preset2_check_playlist) = true;
            else if (preset == 3) id(preset3_check_playlist) = true;
            else if (preset == 4) id(preset4_check_playlist) = true;
          } else if (mode == "out playlist") {
            if (preset == 0) id(preset0_check_playlist) = false;
            else if (preset == 1) id(preset1_check_playlist) = false;
            else if (preset == 2) id(preset2_check_playlist) = false;
            else if (preset == 3) id(preset3_check_playlist) = false;
            else if (preset == 4) id(preset4_check_playlist) = false;
          }

          float corr_value = 0.0f;
          if (preset >= 0 && preset <= 4) {
            if (mode == "sunrise") {
              if (preset == 0) corr_value = id(preset0_sunrise_correction);
              else if (preset == 1) corr_value = id(preset1_sunrise_correction);
              else if (preset == 2) corr_value = id(preset2_sunrise_correction);
              else if (preset == 3) corr_value = id(preset3_sunrise_correction);
              else if (preset == 4) corr_value = id(preset4_sunrise_correction);
            } else if (mode == "sunset") {
              if (preset == 0) corr_value = id(preset0_sunset_correction);
              else if (preset == 1) corr_value = id(preset1_sunset_correction);
              else if (preset == 2) corr_value = id(preset2_sunset_correction);
              else if (preset == 3) corr_value = id(preset3_sunset_correction);
              else if (preset == 4) corr_value = id(preset4_sunset_correction);
            } else {
              corr_value = 0.0f;
            }
          } else if (preset == 5) {
            if (mode == "sunrise") corr_value = id(playlist_sunrise_correction);
            else if (mode == "sunset") corr_value = id(playlist_sunset_correction);
            else corr_value = 0.0f;
          }

          // Обновляем number 
          id(sun_elevation_correction).publish_state(corr_value);
          // Обновляем текстовый сенсор настроек
          id(preset_start_settings).update();
      - lambda: |-
          int preset = id(preset_selected);
          std::string mode = id(mode_selector).state;
          // Новое: Обновляем datetime_picker в зависимости от режима (только для пресетов 0-4)
          if (preset >= 0 && preset <= 4) {
            auto call = id(datetime_picker).make_call();
            if (mode == "in playlist") {
              // Устанавливаем длительность проигрывания (MM:SS)
              std::string duration_id;
              switch(preset) {
                case 0: duration_id = id(preset0_duration_playlist); break;
                case 1: duration_id = id(preset1_duration_playlist); break;
                case 2: duration_id = id(preset2_duration_playlist); break;
                case 3: duration_id = id(preset3_duration_playlist); break;
                case 4: duration_id = id(preset4_duration_playlist); break;
              }
              call.set_time(duration_id.c_str());
              ESP_LOGD("main", "Set datetime to duration for preset %d: %s", preset, duration_id.c_str());
            } else {
              // Устанавливаем время старта (HH:MM) для всех других режимов
              std::string start_time_id;
              switch(preset) {
                case 0: start_time_id = id(preset0_start_time); break;
                case 1: start_time_id = id(preset1_start_time); break;
                case 2: start_time_id = id(preset2_start_time); break;
                case 3: start_time_id = id(preset3_start_time); break;
                case 4: start_time_id = id(preset4_start_time); break;
              }
              call.set_time(start_time_id.c_str());
              ESP_LOGD("main", "Set datetime to start time for preset %d: %s", preset, start_time_id.c_str());
            }
            call.perform();
          } else if (preset == 5) {
            // Для плейлиста всегда используем playlist_start_time (без общей длительности)
            auto call = id(datetime_picker).make_call();
            call.set_time(id(playlist_start_time).c_str());
            call.perform();
          }

number:
  # Number для поправки elevation солнца (обновляется при смене пресета)
  - platform: template
    name: "Sun Elevation Correction"
    id: sun_elevation_correction
    min_value: -90
    max_value: 90
    step: 1
    optimistic: true
    mode: box
    initial_value: 0
    unit_of_measurement: "°"

datetime:
  - platform: template
    type: time
    name: "Start Time"
    id: datetime_picker
    optimistic: true
    initial_value: "00:00:00"

text_sensor:
  - platform: template
    name: "Current SNTP Time"
    icon: mdi:clock
    id: current_sntp_time
    lambda: |-
      char str[17]; time_t currTime = id(sntp_time).now().timestamp;
      strftime(str, sizeof(str), "%Y-%m-%d %H:%M", localtime(&currTime));
      return  { str };
    update_interval: 60s
  - platform: template
    name: "Current HA Time"
    icon: mdi:clock
    id: current_ha_time
    lambda: |-
      char str[17]; time_t currTime = id(homeassistant_time).now().timestamp;
      strftime(str, sizeof(str), "%Y-%m-%d %H:%M", localtime(&currTime));
      return  { str };
    update_interval: 60s
  # Текстовый сенсор для отображения настроек старта (обновляется при смене пресета)
  - platform: template
    name: "Preset Start Settings"
    id: preset_start_settings
    lambda: |-
      std::string state = id(preset_selector).state;
      std::string mode = "None";
      std::string time = "00:00";
      float sunrise_corr = 0.0f;
      float sunset_corr = 0.0f;
      int preset_index = -1;

      if (state == "0") preset_index = 0;
      else if (state == "1") preset_index = 1;
      else if (state == "2") preset_index = 2;
      else if (state == "3") preset_index = 3;
      else if (state == "4") preset_index = 4;
      else if (state == "Playlist") preset_index = 5;

      if (preset_index == 0) {
        mode = id(preset0_start_mode);
        time = id(preset0_start_time);
        sunrise_corr = id(preset0_sunrise_correction);
        sunset_corr = id(preset0_sunset_correction);
      } else if (preset_index == 1) {
        mode = id(preset1_start_mode);
        time = id(preset1_start_time);
        sunrise_corr = id(preset1_sunrise_correction);
        sunset_corr = id(preset1_sunset_correction);
      } else if (preset_index == 2) {
        mode = id(preset2_start_mode);
        time = id(preset2_start_time);
        sunrise_corr = id(preset2_sunrise_correction);
        sunset_corr = id(preset2_sunset_correction);
      } else if (preset_index == 3) {
        mode = id(preset3_start_mode);
        time = id(preset3_start_time);
        sunrise_corr = id(preset3_sunrise_correction);
        sunset_corr = id(preset3_sunset_correction);
      } else if (preset_index == 4) {
        mode = id(preset4_start_mode);
        time = id(preset4_start_time);
        sunrise_corr = id(preset4_sunrise_correction);
        sunset_corr = id(preset4_sunset_correction);
      } else if (preset_index == 5) {
        mode = id(playlist_start_mode);
        time = id(playlist_start_time);
        sunrise_corr = id(playlist_sunrise_correction);
        sunset_corr = id(playlist_sunset_correction);
      } else {
        return std::string("None selected");
      }

      char buf[128];
      // Форматируем строку с корректировками через слеш
      snprintf(buf, sizeof(buf), "Index: %d, Mode: %s, Time: %s, Sun: %.1f° / %.1f°",
        preset_index, mode.c_str(), time.c_str(), sunrise_corr, sunset_corr);
      return std::string(buf);
  - platform: template # Текстовый сенсор для отображения настроек пресетов
    name: "Preset Info"
    id: preset_info
    lambda: |-
      std::string state = id(preset_selector).state;
      int intensity = 0;
      int speed = 0;
      int scale = 0;
      std::string effect_name;
      uint8_t brightness = 0;
      bool in_playlist = false; // флаг для отображения
      // Преобразуем строку в число для индекса пресета
      int preset_index = -1;
      if (state == "0") preset_index = 0;
      else if (state == "1") preset_index = 1;
      else if (state == "2") preset_index = 2;
      else if (state == "3") preset_index = 3;
      else if (state == "4") preset_index = 4;
      else if (state == "Playlist") preset_index = 5;

      if (preset_index == 5) {
        // Формируем строку с эффектами, включёнными в плейлист
        std::string playlist_effects = "Playlist: ";
        bool first = true;
        if (id(preset0_check_playlist)) {
          playlist_effects += id(preset0_effect_name) + " (" + id(preset0_duration_playlist) + ")";
          first = false;
        }
        if (id(preset1_check_playlist)) {
          if (!first) playlist_effects += ", ";
          playlist_effects += id(preset1_effect_name) + " (" + id(preset1_duration_playlist) + ")";
          first = false;
        }
        if (id(preset2_check_playlist)) {
          if (!first) playlist_effects += ", ";
          playlist_effects += id(preset2_effect_name) + " (" + id(preset2_duration_playlist) + ")";
          first = false;
        }
        if (id(preset3_check_playlist)) {
          if (!first) playlist_effects += ", ";
          playlist_effects += id(preset3_effect_name) + " (" + id(preset3_duration_playlist) + ")";
          first = false;
        }
        if (id(preset4_check_playlist)) {
          if (!first) playlist_effects += ", ";
          playlist_effects += id(preset4_effect_name) + " (" + id(preset4_duration_playlist) + ")";
          first = false;
        }
        if (first) {
          // Если ни один пресет не включён в плейлист
          playlist_effects += "(none)";
        }
        return playlist_effects;
      }
      if (preset_index == 0) {
        intensity = id(preset0_intensity);
        speed = id(preset0_speed);
        scale = id(preset0_scale);
        effect_name = id(preset0_effect_name);
        brightness = (uint8_t)(id(preset0_brightness));
        in_playlist = id(preset0_check_playlist);
      } else if (preset_index == 1) {
        intensity = id(preset1_intensity);
        speed = id(preset1_speed);
        scale = id(preset1_scale);
        effect_name = id(preset1_effect_name);
        brightness = (uint8_t)(id(preset1_brightness));
        in_playlist = id(preset1_check_playlist);
      } else if (preset_index == 2) {
        intensity = id(preset2_intensity);
        speed = id(preset2_speed);
        scale = id(preset2_scale);
        effect_name = id(preset2_effect_name);
        brightness = (uint8_t)(id(preset2_brightness));
        in_playlist = id(preset2_check_playlist);
      } else if (preset_index == 3) {
        intensity = id(preset3_intensity);
        speed = id(preset3_speed);
        scale = id(preset3_scale);
        effect_name = id(preset3_effect_name);
        brightness = (uint8_t)(id(preset3_brightness));
        in_playlist = id(preset3_check_playlist);
      } else if (preset_index == 4) {
        intensity = id(preset4_intensity);
        speed = id(preset4_speed);
        scale = id(preset4_scale);
        effect_name = id(preset4_effect_name);
        brightness = (uint8_t)(id(preset4_brightness));
        in_playlist = id(preset4_check_playlist);
      } else {
        return std::string("No preset selected");
      }
      char buf[128];
      int brightness_percent = (brightness * 100 + 127) / 255;  // округление
      snprintf(buf, sizeof(buf),
         "Preset index: %d\nEffect: %s\nIntensity: %d\nSpeed: %d\nScale: %d\nBrightness: %d%%\nPlaylist: %s",
         preset_index,
         effect_name.c_str(),
         intensity,
         speed,
         scale,
         brightness_percent,
         in_playlist ? "yes" : "no"
       );
      return std::string(buf);

script:
  - id: play_preset_playlist
    mode: queued
    then:
      - logger.log: "Скрипт play_preset_playlist стартовал"
      - lambda: |-
          id(preset_info).update();
      # Пресет 0
      - if:
          condition:
            - lambda: |-
                return id(preset_selector).state == "Playlist" && id(preset0_check_playlist);
          then:
            - lambda: |-
                float brightness = (float)id(preset0_brightness) / 255.0f;
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset0_effect_name)).perform();
            - delay: 100ms
            - number.set:
                id: matrix_intensity
                value: !lambda 'return id(preset0_intensity);'
            - number.set:
                id: matrix_speed
                value: !lambda 'return id(preset0_speed);'
            - number.set:
                id: matrix_scale
                value: !lambda 'return id(preset0_scale);'
            - delay: !lambda 'return id(preset0_duration_ms);'
      # Пресет 1
      - if:
          condition:
            - lambda: |-
                return id(preset_selector).state == "Playlist" && id(preset1_check_playlist);
          then:
            - lambda: |-
                float brightness = (float)id(preset1_brightness) / 255.0f;
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset1_effect_name)).perform();
            - delay: 100ms
            - lambda: |-
                id(matrix_intensity).publish_state(id(preset1_intensity));
                id(matrix_speed).publish_state(id(preset1_speed));
                id(matrix_scale).publish_state(id(preset1_scale));
            - delay: !lambda 'return id(preset1_duration_ms);'
      # Пресет 2
      - if:
          condition:
            - lambda: |-
                return id(preset_selector).state == "Playlist" && id(preset2_check_playlist);
          then:
            - lambda: |-
                float brightness = (float)id(preset2_brightness) / 255.0f;
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset2_effect_name)).perform();
            - delay: 100ms
            - lambda: |-
                id(matrix_intensity).publish_state(id(preset2_intensity));
                id(matrix_speed).publish_state(id(preset2_speed));
                id(matrix_scale).publish_state(id(preset2_scale));
            - delay: !lambda 'return id(preset2_duration_ms);'
      # Пресет 3
      - if:
          condition:
            - lambda: |-
                return id(preset_selector).state == "Playlist" && id(preset3_check_playlist);
          then:
            - lambda: |-
                float brightness = (float)id(preset3_brightness) / 255.0f;
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset3_effect_name)).perform();
            - delay: 100ms
            - lambda: |-
                id(matrix_intensity).publish_state(id(preset3_intensity));
                id(matrix_speed).publish_state(id(preset3_speed));
                id(matrix_scale).publish_state(id(preset3_scale));
            - delay: !lambda 'return id(preset3_duration_ms);'
      # Пресет 4
      - if:
          condition:
            - lambda: |-
                return id(preset_selector).state == "Playlist" && id(preset4_check_playlist);
          then:
            - lambda: |-
                float brightness = (float)id(preset4_brightness) / 255.0f;
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset4_effect_name)).perform();
            - delay: 100ms
            - lambda: |-
                id(matrix_intensity).publish_state(id(preset4_intensity));
                id(matrix_speed).publish_state(id(preset4_speed));
                id(matrix_scale).publish_state(id(preset4_scale));
            - delay: !lambda 'return id(preset4_duration_ms);'
            # Запуск скрипта заново
      - script.execute: play_preset_playlist
interval:
  - interval: 30s  # Каждые 30 секунд выполняем проверку на установленное время включения пресетов
    then:
      - if:
          condition:
            - lambda: |-
                // Получаем текущее время в формате "HH:MM" через SNTP (синхронизация времени)
                std::string current_time = id(sntp_time).now().strftime("%H:%M");

                bool apply = false;  // Флаг для запуска пресета
                // Проверяем для каждого пресета, включён ли режим "start on time"
                // и совпадает ли время старта с текущим временем
                if (id(preset0_start_mode) == "start on time" && id(preset0_start_time) == current_time) apply = true;
                else if (id(preset1_start_mode) == "start on time" && id(preset1_start_time) == current_time) apply = true;
                else if (id(preset2_start_mode) == "start on time" && id(preset2_start_time) == current_time) apply = true;
                else if (id(preset3_start_mode) == "start on time" && id(preset3_start_time) == current_time) apply = true;
                else if (id(preset4_start_mode) == "start on time" && id(preset4_start_time) == current_time) apply = true;
                else if (id(playlist_start_mode) == "start on time" && id(playlist_start_time) == current_time) apply = true;

                return apply;  // Если хотя бы один пресет должен стартовать — возвращаем true
          then:
            - lambda: |-
                // Ещё раз получаем текущее время (на всякий случай)
                std::string current_time = id(sntp_time).now().strftime("%H:%M");

                // Для каждого пресета проверяем условие "start on time" и совпадение времени
                if (id(preset0_start_mode) == "start on time" && id(preset0_start_time) == current_time) {
                  // Устанавливаем выбранный пресет
                  id(preset_selected) = 0;
                  // Вычисляем яркость из 0-255 в 0.0-1.0
                  float brightness = (float)id(preset0_brightness) / 255.0f;
                  // Включаем Neopixel с нужной яркостью и эффектом
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset0_effect_name)).perform();

                } else if (id(preset1_start_mode) == "start on time" && id(preset1_start_time) == current_time) {
                  id(preset_selected) = 1;
                  float brightness = (float)id(preset1_brightness) / 255.0f;
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset1_effect_name)).perform();

                } else if (id(preset2_start_mode) == "start on time" && id(preset2_start_time) == current_time) {
                  id(preset_selected) = 2;
                  float brightness = (float)id(preset2_brightness) / 255.0f;
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset2_effect_name)).perform();

                } else if (id(preset3_start_mode) == "start on time" && id(preset3_start_time) == current_time) {
                  id(preset_selected) = 3;
                  float brightness = (float)id(preset3_brightness) / 255.0f;
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset3_effect_name)).perform();

                } else if (id(preset4_start_mode) == "start on time" && id(preset4_start_time) == current_time) {
                  id(preset_selected) = 4;
                  float brightness = (float)id(preset4_brightness) / 255.0f;
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset4_effect_name)).perform();

                } else if (id(playlist_start_mode) == "start on time" && id(playlist_start_time) == current_time) {
                  id(preset_selected) = 5;
                  id(play_preset_playlist).execute();
                }
            - delay: 500ms
# Устанавливаем актуальный пресет в селекторе
            - select.set_index:
                id: preset_selector
                index: !lambda 'return id(preset_selected);'
            - delay: 500ms
            - lambda: |-
                id(preset_info).update();

# Проверяем наличие старта пресетов по солнцу "sunrise" и соответствию положению солнца
      - if:
          condition:
            lambda: |-
              return
                id(preset0_start_mode) == "sunrise" ||
                id(preset1_start_mode) == "sunrise" ||
                id(preset2_start_mode) == "sunrise" ||
                id(preset3_start_mode) == "sunrise" ||
                id(preset4_start_mode) == "sunrise" ||
                id(playlist_start_mode) == "sunrise";
          then:
            - lambda: |-
                float current_sun_angle = id(sun_sun).elevation();
                int current_sun_rounded = (int)round(current_sun_angle);
                std::string current_preset = id(preset_selector).state;

                int triggered_preset = -1; // -1 = не сработало

                for (int i = 0; i <= 5; i++) {
                  std::string start_mode = "";
                  float correction = 0.0f;

                  // Получаем режим и поправку
                  switch (i) {
                    case 0: start_mode = id(preset0_start_mode); correction = id(preset0_sunrise_correction); break;
                    case 1: start_mode = id(preset1_start_mode); correction = id(preset1_sunrise_correction); break;
                    case 2: start_mode = id(preset2_start_mode); correction = id(preset2_sunrise_correction); break;
                    case 3: start_mode = id(preset3_start_mode); correction = id(preset3_sunrise_correction); break;
                    case 4: start_mode = id(preset4_start_mode); correction = id(preset4_sunrise_correction); break;
                    case 5: start_mode = id(playlist_start_mode); correction = id(playlist_sunrise_correction); break;
                  }

                  if (start_mode != "sunrise") continue;
                  float current_sun_angle = id(sun_sun).elevation();
                  int current_sun_rounded = (int)round(current_sun_angle);
                  int target_angle = (int)round(correction); // Целевой угол = поправка
                  if (current_sun_rounded != target_angle) continue;

                  // Запоминаем номер сработавшего пресета
                  triggered_preset = i;

                  // Записываем в глобалку — для последующего использования в select.set_index
                  id(preset_selected) = triggered_preset;

                  break; // срабатывает только первый подходящий пресет
                }

                // Если ничего не сработало — выходим
                if (triggered_preset == -1) {
                  return;
                }

                // Получаем параметры выбранного пресета и запускаем эффект
                float brightness = 0.0f;
                const char* effect_name = "";

                switch (triggered_preset) {
                  case 0:
                    brightness = (float)id(preset0_brightness) / 255.0f;
                    effect_name = id(preset0_effect_name).c_str();
                    break;
                  case 1:
                    brightness = (float)id(preset1_brightness) / 255.0f;
                    effect_name = id(preset1_effect_name).c_str();
                    break;
                  case 2:
                    brightness = (float)id(preset2_brightness) / 255.0f;
                    effect_name = id(preset2_effect_name).c_str();
                    break;
                  case 3:
                    brightness = (float)id(preset3_brightness) / 255.0f;
                    effect_name = id(preset3_effect_name).c_str();
                    break;
                  case 4:
                    brightness = (float)id(preset4_brightness) / 255.0f;
                    effect_name = id(preset4_effect_name).c_str();
                    break;
                  case 5:
                    id(play_preset_playlist).execute();
                    break;
                }

                // Запускаем эффект
                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(effect_name).perform();

            - delay: 500ms
            - select.set_index:
                id: preset_selector
                index: !lambda 'return (int)id(preset_selected);'
            - delay: 500ms
            - lambda: |-
                id(preset_info).update();
     # Проверка запуска пресетов по закату с корректировкой
      - if:
          condition:
            lambda: |-
              return
                id(preset0_start_mode) == "sunset" ||
                id(preset1_start_mode) == "sunset" ||
                id(preset2_start_mode) == "sunset" ||
                id(preset3_start_mode) == "sunset" ||
                id(preset4_start_mode) == "sunset" ||
                id(playlist_start_mode) == "sunset";
          then:
            - lambda: |-
                float current_sun_angle = id(sun_sun).elevation();
                int current_sun_rounded = (int)round(current_sun_angle);
                int triggered_preset = -1;

                for (int i = 0; i <= 6; i++) {
                  std::string start_mode = "";
                  float correction = 0.0f;

                  switch (i) {
                    case 0: start_mode = id(preset0_start_mode); correction = id(preset0_sunset_correction); break;
                    case 1: start_mode = id(preset1_start_mode); correction = id(preset1_sunset_correction); break;
                    case 2: start_mode = id(preset2_start_mode); correction = id(preset2_sunset_correction); break;
                    case 3: start_mode = id(preset3_start_mode); correction = id(preset3_sunset_correction); break;
                    case 4: start_mode = id(preset4_start_mode); correction = id(preset4_sunset_correction); break;
                    case 5: start_mode = id(playlist_start_mode); correction = id(playlist_sunset_correction); break;
                  }

                  if (start_mode != "sunset") continue;

                  int target_angle = (int)round(correction);
                  if (current_sun_rounded != target_angle) continue;

                  triggered_preset = i;
                  id(preset_selected) = triggered_preset;
                  break;
                }

                if (triggered_preset == -1) return;

                float brightness = 0.0f;
                const char* effect_name = "";

                switch (triggered_preset) {
                  case 0:
                    brightness = (float)id(preset0_brightness) / 255.0f;
                    effect_name = id(preset0_effect_name).c_str();
                    break;
                  case 1:
                    brightness = (float)id(preset1_brightness) / 255.0f;
                    effect_name = id(preset1_effect_name).c_str();
                    break;
                  case 2:
                    brightness = (float)id(preset2_brightness) / 255.0f;
                    effect_name = id(preset2_effect_name).c_str();
                    break;
                  case 3:
                    brightness = (float)id(preset3_brightness) / 255.0f;
                    effect_name = id(preset3_effect_name).c_str();
                    break;
                  case 4:
                    brightness = (float)id(preset4_brightness) / 255.0f;
                    effect_name = id(preset4_effect_name).c_str();
                    break;
                  case 5:
                    id(play_preset_playlist).execute();
                    return;
                }

                id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(effect_name).perform();
            - delay: 500ms
            - select.set_index:
                id: preset_selector
                index: !lambda 'return (int)id(preset_selected);'
            - delay: 500ms
            - lambda: |-
                id(preset_info).update();
# Проверяем состояние сенсоров день-ночь и если в пресетах используются эти режимы - работаем с ними
  - interval: 300s
    then:
      - if:
# Если хоть одно условие совпадает - выполняем следующую лямбду.
          condition:
            lambda: |-
              // Определяем день и ночь по углу солнца
              bool is_day = id(sun_sun).elevation() > 0;
              bool is_night = id(sun_sun).elevation() < 0;
              return
                ((id(preset0_start_mode) == "day" || id(preset1_start_mode) == "day" || id(preset2_start_mode) == "day" ||
                  id(preset3_start_mode) == "day" || id(preset4_start_mode) == "day" || id(playlist_start_mode) == "day") && is_day)
                ||
                ((id(preset0_start_mode) == "night" || id(preset1_start_mode) == "night" || id(preset2_start_mode) == "night" ||
                  id(preset3_start_mode) == "night" || id(preset4_start_mode) == "night" || id(playlist_start_mode) == "night") && is_night);
          then:
            - lambda: |-
                bool is_day = id(sun_sun).elevation()> 0;
                bool is_night = id(sun_sun).elevation()< 0;
                // Пример для preset0: если режим "day" и сейчас день, или "night" и сейчас ночь
                if ((id(preset0_start_mode) == "day" && is_day) ||
                    (id(preset0_start_mode) == "night" && is_night)) {
                  id(preset_selected) = 0;
                  // Получаем яркость от 0 до 255 и нормируем до 0.0 - 1.0
                  float brightness = (float)id(preset0_brightness) / 255.0f;
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset0_effect_name)).perform();
                }

                if ((id(preset1_start_mode) == "day" && is_day) ||
                    (id(preset1_start_mode) == "night" && is_night)) {
                  id(preset_selected) = 1;
                  float brightness = (float)id(preset1_brightness) / 255.0f;
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset1_effect_name)).perform();
                }

                if ((id(preset2_start_mode) == "day" && is_day) ||
                    (id(preset2_start_mode) == "night" && is_night)) {
                  id(preset_selected) = 2;
                  float brightness = (float)id(preset2_brightness) / 255.0f;
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset2_effect_name)).perform();
                }
                if ((id(preset3_start_mode) == "day" && is_day) ||
                    (id(preset3_start_mode) == "night" && is_night)) {
                  id(preset_selected) = 3;
                  float brightness = (float)id(preset3_brightness) / 255.0f;
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset3_effect_name)).perform();
                }
                if ((id(preset4_start_mode) == "day" && is_day) ||
                    (id(preset4_start_mode) == "night" && is_night)) {
                  id(preset_selected) = 4;
                  float brightness = (float)id(preset4_brightness) / 255.0f;
                  id(neopixel_led)->turn_on().set_brightness(brightness).set_effect(id(preset4_effect_name)).perform();
                }
                if ((id(playlist_start_mode) == "day" && is_day) ||
                    (id(playlist_start_mode) == "night" && is_night)) {
                  id(preset_selected) = 4;
                  id(play_preset_playlist).execute();
                }
            - delay: 500ms
            - select.set_index:
                id: preset_selector
                index: !lambda 'return id(preset_selected);'
            - delay: 500ms
            - lambda: |-
                id(preset_info).update(); //Обновляем информацию о пресете ( текстовый сенсор) если несколько пресетов одновременно соответствуют условию, то в итоге будет применён последний из них